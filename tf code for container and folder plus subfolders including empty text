provider "azurerm" {
  features {}
}

# Reference existing storage account from module
variable "storage_account_name" {
  default = "mystorageaccount"  # Change if your module provides an output
}

# Define Storage Containers
variable "containers" {
  default = ["container1", "container2", "container3", "newcontainer"]
}

resource "azurerm_storage_container" "containers" {
  for_each              = toset(var.containers)
  name                  = each.key
  storage_account_name  = module.storage_account.name  # Reference existing module
  container_access_type = "private"
}

# Define folder structure
variable "folders" {
  default = ["folder1/", "folder2/", "folder3/", "folder4/"]
}

variable "subfolders" {
  default = {
    "folder1" = ["subfolderA", "subfolderB"]
    "folder2" = ["subfolderX", "subfolderY"]
    "folder3" = ["subfolderM", "subfolderN"]
  }
}

# Upload empty blobs to simulate top-level folders
resource "azurerm_storage_blob" "top_level_folders" {
  for_each = { for folder in var.folders : folder => folder }

  name                   = "${each.key}empty.txt"
  storage_account_name   = module.storage_account.name  # Reference existing module
  storage_container_name = azurerm_storage_container.containers["container1"].name  # Adjust container if needed
  type                   = "Block"
  source_content         = ""

  lifecycle {
    ignore_changes = [source_content]
  }
}

# Upload empty blobs to simulate subfolders in all containers
resource "azurerm_storage_blob" "subfolders" {
  for_each = { 
    for container in var.containers : 
    merge({
      for parent, subs in var.subfolders : 
      merge({
        for sub in subs : "${container}_${parent}_${sub}" => {
          container = container
          path      = "${parent}/${sub}/empty.txt"
        }
      })
    })
  }

  name                   = each.value.path  # Path to the simulated folder
  storage_account_name   = module.storage_account.name  # Reference existing storage module
  storage_container_name = azurerm_storage_container.containers[each.value.container].name
  type                   = "Block"
  source_content         = ""

  lifecycle {
    ignore_changes = [source_content]
  }
}
